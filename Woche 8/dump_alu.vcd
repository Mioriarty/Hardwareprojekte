$date
	Thu Jun  2 11:39:19 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module alu_tb $end
$var wire 8 ! l_result [7:0] $end
$var wire 1 " l_carry_out $end
$var reg 8 # l_a [7:0] $end
$var reg 2 $ l_alu_ctrl [1:0] $end
$var reg 8 % l_b [7:0] $end
$scope module dut $end
$var wire 8 & i_a [7:0] $end
$var wire 2 ' i_alu_ctrl [1:0] $end
$var wire 8 ( i_b [7:0] $end
$var wire 8 ) l_and_result [7:0] $end
$var wire 8 * l_neg_b [7:0] $end
$var wire 8 + l_or_result [7:0] $end
$var wire 8 , o_result [7:0] $end
$var wire 1 " o_carry_out $end
$var wire 8 - l_transform_b [7:0] $end
$var wire 8 . l_sum_result [7:0] $end
$scope module adder $end
$var wire 8 / i_a [7:0] $end
$var wire 1 0 i_carry_in $end
$var wire 1 " o_carry_out $end
$var wire 8 1 o_c [7:0] $end
$var wire 8 2 i_b [7:0] $end
$upscope $end
$scope module mux4 $end
$var wire 8 3 i_in0 [7:0] $end
$var wire 8 4 i_in1 [7:0] $end
$var wire 8 5 i_in2 [7:0] $end
$var wire 8 6 i_in3 [7:0] $end
$var wire 2 7 i_s [1:0] $end
$var wire 8 8 temp2 [7:0] $end
$var wire 8 9 temp1 [7:0] $end
$var wire 8 : o_out [7:0] $end
$scope module m1 $end
$var wire 8 ; i_in0 [7:0] $end
$var wire 8 < i_in1 [7:0] $end
$var wire 1 = i_s $end
$var wire 8 > o_out [7:0] $end
$upscope $end
$scope module m2 $end
$var wire 8 ? i_in0 [7:0] $end
$var wire 8 @ i_in1 [7:0] $end
$var wire 1 A i_s $end
$var wire 8 B o_out [7:0] $end
$upscope $end
$scope module m_super $end
$var wire 8 C i_in0 [7:0] $end
$var wire 8 D i_in1 [7:0] $end
$var wire 1 E i_s $end
$var wire 8 F o_out [7:0] $end
$upscope $end
$upscope $end
$scope module transform_mux $end
$var wire 8 G i_in0 [7:0] $end
$var wire 8 H i_in1 [7:0] $end
$var wire 1 I i_s $end
$var wire 8 J o_out [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 J
0I
b11111111 H
b0 G
b0 F
0E
b0 D
b0 C
b0 B
0A
b0 @
b0 ?
b0 >
0=
b0 <
b0 ;
b0 :
b0 9
b0 8
b0 7
b0 6
b0 5
b0 4
b0 3
b0 2
b0 1
00
b0 /
b0 .
b0 -
b0 ,
b0 +
b11111111 *
b0 )
b0 (
b0 '
b0 &
b0 %
b0 $
b0 #
0"
b0 !
$end
#10
b1100010 !
b1100010 ,
b1100010 :
b1100010 F
1"
b10100101 8
b10100101 B
b10100101 D
b1100010 9
b1100010 >
b1100010 C
b1011010 *
b1011010 H
b10100101 -
b10100101 2
b10100101 J
b10100101 )
b10100101 5
b10100101 ?
b10111101 +
b10111101 6
b10111101 @
b1100010 .
b1100010 1
b1100010 3
b1100010 4
b1100010 ;
b1100010 <
b10100101 %
b10100101 (
b10100101 G
b10111101 #
b10111101 &
b10111101 /
#20
b11000 !
b11000 ,
b11000 :
b11000 F
b11000 9
b11000 >
b11000 C
b1011010 -
b1011010 2
b1011010 J
b11000 .
b11000 1
b11000 3
b11000 4
b11000 ;
b11000 <
b10111101 8
b10111101 B
b10111101 D
1I
10
1=
1A
b1 $
b1 '
b1 7
#30
b1100010 9
b1100010 >
b1100010 C
b10100101 -
b10100101 2
b10100101 J
b1100010 .
b1100010 1
b1100010 3
b1100010 4
b1100010 ;
b1100010 <
b10100101 8
b10100101 B
b10100101 D
b10100101 !
b10100101 ,
b10100101 :
b10100101 F
0I
00
0=
0A
1E
b10 $
b10 '
b10 7
#40
b11000 9
b11000 >
b11000 C
b10111101 !
b10111101 ,
b10111101 :
b10111101 F
b1011010 -
b1011010 2
b1011010 J
b11000 .
b11000 1
b11000 3
b11000 4
b11000 ;
b11000 <
b10111101 8
b10111101 B
b10111101 D
1I
10
1=
1A
b11 $
b11 '
b11 7
#50
