$date
	Thu Jun  9 11:39:00 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module alu_nzcv_tb $end
$var wire 32 ! l_res [31:0] $end
$var wire 4 " l_nzcv [3:0] $end
$var reg 32 # l_a [31:0] $end
$var reg 2 $ l_alu_ctrl [1:0] $end
$var reg 32 % l_b [31:0] $end
$scope module dut $end
$var wire 32 & i_a [31:0] $end
$var wire 2 ' i_alu_ctrl [1:0] $end
$var wire 32 ( i_b [31:0] $end
$var wire 1 ) l_compared_signs $end
$var wire 32 * l_res_10 [31:0] $end
$var wire 32 + l_res_11 [31:0] $end
$var wire 32 , o_result [31:0] $end
$var wire 4 - o_nzcv [3:0] $end
$var wire 32 . l_sum [31:0] $end
$var wire 1 / l_disable_ov $end
$var wire 32 0 l_b_tmp [31:0] $end
$var wire 1 1 l_adder_carry $end
$scope module adder_ab $end
$var wire 32 2 i_a [31:0] $end
$var wire 1 3 i_carry_in $end
$var wire 1 1 o_carry_out $end
$var wire 32 4 o_c [31:0] $end
$var wire 32 5 i_b [31:0] $end
$upscope $end
$scope module mux_b $end
$var wire 32 6 i_in0 [31:0] $end
$var wire 32 7 i_in1 [31:0] $end
$var wire 1 8 i_s $end
$var wire 32 9 o_out [31:0] $end
$upscope $end
$scope module mux_result $end
$var wire 32 : i_in0 [31:0] $end
$var wire 32 ; i_in1 [31:0] $end
$var wire 32 < i_in2 [31:0] $end
$var wire 32 = i_in3 [31:0] $end
$var wire 2 > i_s [1:0] $end
$var wire 32 ? o_out [31:0] $end
$var wire 32 @ l_low [31:0] $end
$var wire 32 A l_high [31:0] $end
$scope module mux_final $end
$var wire 1 B i_s $end
$var wire 32 C o_out [31:0] $end
$var wire 32 D i_in1 [31:0] $end
$var wire 32 E i_in0 [31:0] $end
$upscope $end
$scope module mux_high $end
$var wire 32 F i_in0 [31:0] $end
$var wire 32 G i_in1 [31:0] $end
$var wire 1 H i_s $end
$var wire 32 I o_out [31:0] $end
$upscope $end
$scope module mux_low $end
$var wire 32 J i_in0 [31:0] $end
$var wire 32 K i_in1 [31:0] $end
$var wire 1 L i_s $end
$var wire 32 M o_out [31:0] $end
$upscope $end
$upscope $end
$scope module ov_xor $end
$var wire 1 N i_in0 $end
$var wire 1 O i_in1 $end
$var wire 1 P i_in2 $end
$var wire 1 Q l_res1 $end
$var wire 1 / o_res $end
$upscope $end
$upscope $end
$upscope $end
$scope module decoder $end
$var wire 4 R i_binary_number [3:0] $end
$var reg 7 S o_display [6:0] $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx S
bz R
0Q
0P
0O
0N
b0 M
0L
b0 K
b0 J
b0 I
0H
b0 G
b0 F
b0 E
b0 D
b0 C
0B
b0 A
b0 @
b0 ?
b0 >
b0 =
b0 <
b0 ;
b0 :
b0 9
08
b11111111111111111111111111111111 7
b0 6
b0 5
b0 4
03
b0 2
01
b0 0
0/
b0 .
b100 -
b0 ,
b0 +
b0 *
0)
b0 (
b0 '
b0 &
b0 %
b0 $
b0 #
b100 "
b0 !
$end
#10
b1000 "
b1000 -
b11111111111111111111111111111111 !
b11111111111111111111111111111111 ,
b11111111111111111111111111111111 ?
b11111111111111111111111111111111 C
1)
1/
b11111111111111111111111111111111 @
b11111111111111111111111111111111 E
b11111111111111111111111111111111 M
1Q
b11111111111111111111111111111111 .
b11111111111111111111111111111111 4
b11111111111111111111111111111111 :
b11111111111111111111111111111111 ;
b11111111111111111111111111111111 J
b11111111111111111111111111111111 K
b0 7
b11111111111111111111111111111111 +
b11111111111111111111111111111111 =
b11111111111111111111111111111111 G
1O
b11111111111111111111111111111111 0
b11111111111111111111111111111111 5
b11111111111111111111111111111111 9
b11111111111111111111111111111111 %
b11111111111111111111111111111111 (
b11111111111111111111111111111111 6
#20
b0 !
b0 ,
b0 ?
b0 C
0)
b1 A
b1 D
b1 I
b0 @
b0 E
b0 M
b110 "
b110 -
b1 *
b1 <
b1 F
b0 .
b0 4
b0 :
b0 ;
b0 J
b0 K
11
b1 #
b1 &
b1 2
#30
0/
b0 "
b0 -
b10000000000000000 !
b10000000000000000 ,
b10000000000000000 ?
b10000000000000000 C
0Q
01
b10000000000000000 @
b10000000000000000 E
b10000000000000000 M
b11111111111111111111111111111110 7
0O
b1 0
b1 5
b1 9
b1111111111111111 +
b1111111111111111 =
b1111111111111111 G
b10000000000000000 .
b10000000000000000 4
b10000000000000000 :
b10000000000000000 ;
b10000000000000000 J
b10000000000000000 K
b1 %
b1 (
b1 6
b1111111111111111 #
b1111111111111111 &
b1111111111111111 2
#40
b110 "
b110 -
11
b0 !
b0 ,
b0 ?
b0 C
1/
b0 A
b0 D
b0 I
b0 @
b0 E
b0 M
18
13
1P
1L
1H
b11111111111111111111111111111111 7
b11111111111111111111111111111111 0
b11111111111111111111111111111111 5
b11111111111111111111111111111111 9
b0 *
b0 <
b0 F
b0 +
b0 =
b0 G
b0 .
b0 4
b0 :
b0 ;
b0 J
b0 K
b1 $
b1 '
b1 >
b0 %
b0 (
b0 6
b0 #
b0 &
b0 2
#50
b10 "
b10 -
b1111111111111111 !
b1111111111111111 ,
b1111111111111111 ?
b1111111111111111 C
b11111111111111111111111111111110 0
b11111111111111111111111111111110 5
b11111111111111111111111111111110 9
b10000000000000001 A
b10000000000000001 D
b10000000000000001 I
b1111111111111111 @
b1111111111111111 E
b1111111111111111 M
b11111111111111111111111111111110 7
b10000000000000001 +
b10000000000000001 =
b10000000000000001 G
b1111111111111111 .
b1111111111111111 4
b1111111111111111 :
b1111111111111111 ;
b1111111111111111 J
b1111111111111111 K
b1 %
b1 (
b1 6
b10000000000000000 #
b10000000000000000 &
b10000000000000000 2
#60
b1000 "
b1000 -
0/
b11111111111111111111111111111111 !
b11111111111111111111111111111111 ,
b11111111111111111111111111111111 ?
b11111111111111111111111111111111 C
b11111111111111111111111111111111 0
b11111111111111111111111111111111 5
b11111111111111111111111111111111 9
b11111111111111111111111111111111 A
b11111111111111111111111111111111 D
b11111111111111111111111111111111 I
b11111111111111111111111111111110 @
b11111111111111111111111111111110 E
b11111111111111111111111111111110 M
08
03
0P
0L
0H
1B
b0 7
1O
b11111111111111111111111111111111 *
b11111111111111111111111111111111 <
b11111111111111111111111111111111 F
b11111111111111111111111111111111 +
b11111111111111111111111111111111 =
b11111111111111111111111111111111 G
1N
b11111111111111111111111111111110 .
b11111111111111111111111111111110 4
b11111111111111111111111111111110 :
b11111111111111111111111111111110 ;
b11111111111111111111111111111110 J
b11111111111111111111111111111110 K
b10 $
b10 '
b10 >
b11111111111111111111111111111111 %
b11111111111111111111111111111111 (
b11111111111111111111111111111111 6
b11111111111111111111111111111111 #
b11111111111111111111111111111111 &
b11111111111111111111111111111111 2
#70
b0 "
b0 -
1)
b1110111010000110011010001110111 !
b1110111010000110011010001110111 ,
b1110111010000110011010001110111 ?
b1110111010000110011010001110111 C
1/
b1110111010000110011010001110110 @
b1110111010000110011010001110110 E
b1110111010000110011010001110110 M
b1110111010000110011010001110111 A
b1110111010000110011010001110111 D
b1110111010000110011010001110111 I
1Q
b1110111010000110011010001110110 .
b1110111010000110011010001110110 4
b1110111010000110011010001110110 :
b1110111010000110011010001110110 ;
b1110111010000110011010001110110 J
b1110111010000110011010001110110 K
b10001000101111001100101110001000 7
b1110111010000110011010001110111 *
b1110111010000110011010001110111 <
b1110111010000110011010001110111 F
0O
b1110111010000110011010001110111 0
b1110111010000110011010001110111 5
b1110111010000110011010001110111 9
b1110111010000110011010001110111 %
b1110111010000110011010001110111 (
b1110111010000110011010001110111 6
#80
b100 "
b100 -
b0 !
b0 ,
b0 ?
b0 C
b0 A
b0 D
b0 I
1)
b11111111111111111111111111111111 @
b11111111111111111111111111111111 E
b11111111111111111111111111111111 M
b0 7
1O
b11111111111111111111111111111111 0
b11111111111111111111111111111111 5
b11111111111111111111111111111111 9
b0 *
b0 <
b0 F
0N
b11111111111111111111111111111111 .
b11111111111111111111111111111111 4
b11111111111111111111111111111111 :
b11111111111111111111111111111111 ;
b11111111111111111111111111111111 J
b11111111111111111111111111111111 K
01
b11111111111111111111111111111111 %
b11111111111111111111111111111111 (
b11111111111111111111111111111111 6
b0 #
b0 &
b0 2
#90
0)
b1000 "
b1000 -
b1 @
b1 E
b1 M
b11111111111111111111111111111111 !
b11111111111111111111111111111111 ,
b11111111111111111111111111111111 ?
b11111111111111111111111111111111 C
b0 0
b0 5
b0 9
b1 .
b1 4
b1 :
b1 ;
b1 J
b1 K
01
0/
b11111111111111111111111111111111 A
b11111111111111111111111111111111 D
b11111111111111111111111111111111 I
18
13
1P
1L
1H
b11 $
b11 '
b11 >
#100
